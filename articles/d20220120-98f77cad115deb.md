---
title: "リリースフラグによってプルリクを小さくする"
emoji: "🏳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go", "プルリクエスト"]
published: false
---

# 先にまとめ


# 解説しようとしていること

## 「変更」を「追加」と「削除」に分ける

リファクタリングと仕様変更はプルリクとしては分けた方がレビューコストが下がる、というのは有名な話ですし、実際にレビューをしたことがある方々なら実感できるでしょう。
参考: [レビューをもらいやすい細かいプルリクの切り分け方 - Software engineering from east direction](https://khigashigashi.hatenablog.com/entry/2018/03/09/020359)

加えて、**「変更」を「追加」と「削除」に分けた方が良い**、という話をします。
追加・削除・変更のプルリクを見たときに、レビュアは以下のような観点でそれぞれレビューするかと思います。

- 追加: プルリクでは追加行が中身となり、その追加する箇所が仕様の機能を実現できているかをレビューする。設計が正しいものかの観点でもレビューする。
- 削除: プルリクでは削除行が中身となり、削除する箇所が不要となっているかをレビューする。削除漏れなどがないかもレビューする。
- 変更: プルリクでは追加行と削除行が混在し、旧実装で実現できていたことが新実装で実現できているかをレビューする。本当は設計や削除漏れも細かく見た方が良いが、あまりそこまで頭が回らない。

考えてみれば、変更は追加と削除を合わせたものなので、追加単体・削除単体のプルリクと比較したら、レビューコストは飛躍的に上昇してしまいます。
つまり、レビューコストは **変更 > 追加 ≒ 削除** ということになります。
可能であれば、変更は追加と削除に分けましょう。

## 「変更」と「リリース」を分ける

また、「変更」と「リリース」も分けた方が良い、という話をします。
マージするとリリースされてしまう機能だというのは、それだけで懸念点が増え、レビューコストが上がります。
「基本的にはLGTMですが、この機能はXX月XX日にリリース予定ですよね？なので今マージするとまずい気がしてます。 そういえばデータベースのマイグレーションも行わなければならないですね。あと互換性が・・・」みたいなコメントを打つことに注意力が持ってかれます。

- 変更: 本当は設計として正しいか・仕様を満たしているかを中身にレビューしたい
- リリース: リリースタイミング・マイグレーション・互換性などがレビューの観点となる

レビュアを設計のレビューに集中させるためにも、 この2つも可能であれば分けた方が良いでしょう。
本記事では **変更 = 追加 + リリース + 削除** であるとし、変更のプルリクを分割する方法について解説します。

# 実装

実装の説明ではGoを使ってますが、あんまり言語は関係ないです。

## 実装例の前提

私たちが所属するA社の運営するサービスには、宝くじを申し込む機能があります。
宝くじの申し込みを受け、その申し込み情報やユーザ情報によって、運用により実際に宝くじを出していました。
この運用業務を外部委託することになり、外部委託先をHoge社とします。
Hoge社にはWEB APIによって連携することになりました。

- 旧仕様: 申し込み情報を保持しておき、その情報を元に通知を作成する。
- 新仕様: 申し込み情報を元にHoge社にAPIを出し、その情報を保持しておくだけでOK。 通知はHoge社から出されてしまうので、入れないことにした。

簡単にまとめると、既に動いている機能の仕様を変えようとしているってことです。

## 変更をそのままプルリクにした場合

旧仕様の実装は以下です。

```go
package usecase

import (
	"errors"
	"example.com/go-mod-test/flag/pkg"
)

type RegisterLotteryOrderUsecase struct {
	lotteryOrderRepo *pkg.LotteryOrderRepository
	notificationRepo *pkg.NotificationRepository
}

func (u *RegisterLotteryOrderUsecase) exec(uid string) (lotteryOrderID string, err error) {
	id, err := pkg.GenerateID()
	if err != nil {
		return "", err
	}

	// 宝くじの注文を作成
	lotteryOrder, err := pkg.NewLotteryOrder(id, uid, "", "")
	if err != nil {
		return "", errors.New("failed to create new lottery order")
	}

	// その注文を永続化
	err = u.lotteryOrderRepo.Save(lotteryOrder)
	if err != nil {
		return "", errors.New("failed to save lottery order")
	}

	// 宝くじの注文の通知を作成
	notif, err := pkg.NewNotificationOfRegisteringLotteryOrder(lotteryOrder)
	if err != nil {
		return "", errors.New("failed to create notification")
	}

	// その通知を永続化。通知も飛ばしてくれるとする
	err = u.notificationRepo.Save(notif)
	if err != nil {
		return "", errors.New("failed to save notification")
	}

	return lotteryOrder.LotteryOrderID, nil
}
```

新仕様の実装は以下です。

```go
package usecase

import (
	"errors"
	"example.com/go-mod-test/flag/pkg"
)

type HogeClient struct{}

func (c *HogeClient) postLotteries(_ string) (string, error) {
	// emailを使って、Hoge社の宝くじの注文するAPIを叩いて、Hoge社管理の宝くじIDが返ってくるとしましょう
	return "12345", nil
}

type RegisterLotteryOrderUsecase struct {
	hoge             *HogeClient
	userRepo         *pkg.UserRepository
	lotteryOrderRepo *pkg.LotteryOrderRepository
}

func (u *RegisterLotteryOrderUsecase) exec(uid string) (lotteryOrderID string, err error) {
	id, err := pkg.GenerateID()
	if err != nil {
		return "", err
	}

	// Emailを出すために該当ユーザを抽出
	user := u.userRepo.FindByUID(uid)

	// Hoge社にAPIで連携。このときに通知も飛ぶ
	hogeLotteryOrderID, err := u.hoge.postLotteries(user.Email)

	// 内部で管理するため、宝くじの注文を作成
	lotteryOrder, err := pkg.NewLotteryOrder(id, uid, "hoge", hogeLotteryOrderID)
	if err != nil {
		return "", errors.New("failed to create new lottery order")
	}

	// その注文を永続化
	err = u.lotteryOrderRepo.Save(lotteryOrder)
	if err != nil {
		return "", errors.New("failed to save lottery order")
	}

	return lotteryOrder.LotteryOrderID, nil
}
```

旧実装と新実装のdiffを取ると以下のようになります。

```diff go
 package usecase
 
 import (
        "errors"
        "example.com/go-mod-test/flag/pkg"
 )
 
+type HogeClient struct{}
+
+func (c *HogeClient) postLotteries(_ string) (string, error) {
+       // emailを使って、Hoge社の宝くじの注文するAPIを叩いて、Hoge社管理の宝くじIDが返ってくるとしましょう
+       return "12345", nil
+}
+
 type RegisterLotteryOrderUsecase struct {
+       hoge             *HogeClient
+       userRepo         *pkg.UserRepository
        lotteryOrderRepo *pkg.LotteryOrderRepository
-       notificationRepo *pkg.NotificationRepository
 }
 
 func (u *RegisterLotteryOrderUsecase) exec(uid string) (lotteryOrderID string, err error) {
        id, err := pkg.GenerateID()
        if err != nil {
                return "", err
        }
 
-       // 宝くじの注文を作成
-       lotteryOrder, err := pkg.NewLotteryOrder(id, uid, "", "")
+       // Emailを出すために該当ユーザを抽出
+       user := u.userRepo.FindByUID(uid)
+
+       // Hoge社にAPIで連携。このときに通知も飛ぶ
+       hogeLotteryOrderID, err := u.hoge.postLotteries(user.Email)
+
+       // 内部で管理するため、宝くじの注文を作成
+       lotteryOrder, err := pkg.NewLotteryOrder(id, uid, "hoge", hogeLotteryOrderID)
        if err != nil {
                return "", errors.New("failed to create new lottery order")
        }
 
        // その注文を永続化
        err = u.lotteryOrderRepo.Save(lotteryOrder)
        if err != nil {
                return "", errors.New("failed to save lottery order")
        }
 
-       // 宝くじの注文の通知を作成
-       notif, err := pkg.NewNotificationOfRegisteringLotteryOrder(lotteryOrder)
-       if err != nil {
-               return "", errors.New("failed to create notification")
-       }
-
-       // その通知を永続化。通知も飛ばしてくれるとする
-       err = u.notificationRepo.Save(notif)
-       if err != nil {
-               return "", errors.New("failed to save notification")
-       }
-
        return lotteryOrder.LotteryOrderID, nil
 }
```

diffの中に旧実装の削除と、新実装の追加が混在しています。[^1]

## プルリクを分けるやり方

新実装の方を、以下のように実装します。

```go
package usecase

import (
	"errors"
	"example.com/go-mod-test/flag/pkg"
)

const registersLotteryWithHoge = false

type HogeClient struct{}

func (c *HogeClient) postLotteries(_ string) (string, error) {
	// emailを使って、Hoge社の宝くじの注文するAPIを叩いて、Hoge社管理の宝くじIDが返ってくるとしましょう
	return "12345", nil
}

type RegisterLotteryOrderUsecase struct {
	hoge             *HogeClient
	userRepo         *pkg.UserRepository
	lotteryOrderRepo *pkg.LotteryOrderRepository
	notificationRepo *pkg.NotificationRepository
}

func (u *RegisterLotteryOrderUsecase) exec(uid string) (lotteryOrderID string, err error) {
	id, err := pkg.GenerateID()
	if err != nil {
		return "", err
	}

	if registersLotteryWithHoge {
		// Emailを出すために該当ユーザを抽出
		user := u.userRepo.FindByUID(uid)

		// Hoge社にAPIで連携。このときに通知も飛ぶ
		hogeLotteryOrderID, err := u.hoge.postLotteries(user.Email)

		// 内部で管理するため、宝くじの注文を作成
		lotteryOrder, err := pkg.NewLotteryOrder(id, uid, "hoge", hogeLotteryOrderID)
		if err != nil {
			return "", errors.New("failed to create new lottery order")
		}

		// その注文を永続化
		err = u.lotteryOrderRepo.Save(lotteryOrder)
		if err != nil {
			return "", errors.New("failed to save lottery order")
		}

		return lotteryOrder.LotteryOrderID, nil
	}

	// 宝くじの注文を作成
	lotteryOrder, err := pkg.NewLotteryOrder(id, uid, "", "")
	if err != nil {
		return "", errors.New("failed to create new lottery order")
	}

	// その注文を永続化
	err = u.lotteryOrderRepo.Save(lotteryOrder)
	if err != nil {
		return "", errors.New("failed to save lottery order")
	}

	// 宝くじの注文の通知を作成
	notif, err := pkg.NewNotificationOfRegisteringLotteryOrder(lotteryOrder)
	if err != nil {
		return "", errors.New("failed to create notification")
	}

	// その通知を永続化。通知も飛ばしてくれるとする
	err = u.notificationRepo.Save(notif)
	if err != nil {
		return "", errors.New("failed to save notification")
	}

	return lotteryOrder.LotteryOrderID, nil
}
```

ポイントは以下です。

- `registersLotteryWithHoge`という、リリースフラグを設ける。これを切り替えれば新実装がリリースされることになる。機能開発時には旧実装の方に処理が進むようにする。
- 新実装は追加行だけで表現できるようにする。
- 旧実装はまるごと残す(削除しない)。

こうすることで、diffは以下の通りになります。

```diff go
 package usecase
 
 import (
        "errors"
        "example.com/go-mod-test/flag/pkg"
 )
 
+const registersLotteryWithHoge = false
+
+type HogeClient struct{}
+
+func (c *HogeClient) postLotteries(_ string) (string, error) {
+       // emailを使って、Hoge社の宝くじの注文するAPIを叩いて、Hoge社管理の宝くじIDが返ってくるとしましょう
+       return "12345", nil
+}
+
 type RegisterLotteryOrderUsecase struct {
+       hoge             *HogeClient
+       userRepo         *pkg.UserRepository
        lotteryOrderRepo *pkg.LotteryOrderRepository
        notificationRepo *pkg.NotificationRepository
 }
 
 func (u *RegisterLotteryOrderUsecase) exec(uid string) (lotteryOrderID string, err error) {
        id, err := pkg.GenerateID()
        if err != nil {
                return "", err
        }
 
+       if registersLotteryWithHoge {
+               // Emailを出すために該当ユーザを抽出
+               user := u.userRepo.FindByUID(uid)
+
+               // Hoge社にAPIで連携。このときに通知も飛ぶ
+               hogeLotteryOrderID, err := u.hoge.postLotteries(user.Email)
+
+               // 内部で管理するため、宝くじの注文を作成
+               lotteryOrder, err := pkg.NewLotteryOrder(id, uid, "hoge", hogeLotteryOrderID)
+               if err != nil {
+                       return "", errors.New("failed to create new lottery order")
+               }
+
+               // その注文を永続化
+               err = u.lotteryOrderRepo.Save(lotteryOrder)
+               if err != nil {
+                       return "", errors.New("failed to save lottery order")
+               }
+
+               return lotteryOrder.LotteryOrderID, nil
+       }
+
        // 宝くじの注文を作成
        lotteryOrder, err := pkg.NewLotteryOrder(id, uid, "", "")
        if err != nil {
                return "", errors.New("failed to create new lottery order")
        }
 
        // その注文を永続化
        err = u.lotteryOrderRepo.Save(lotteryOrder)
        if err != nil {
                return "", errors.New("failed to save lottery order")
        }
 
        // 宝くじの注文の通知を作成
        notif, err := pkg.NewNotificationOfRegisteringLotteryOrder(lotteryOrder)
        if err != nil {
                return "", errors.New("failed to create notification")
        }
 
        // その通知を永続化。通知も飛ばしてくれるとする
        err = u.notificationRepo.Save(notif)
        if err != nil {
                return "", errors.New("failed to save notification")
        }
 
        return lotteryOrder.LotteryOrderID, nil
 }
```

新実装を追加行だけで表現することができました。
これはレビュア目線だと以下の効果があると思います。

- 旧実装がそのまま残っているので、旧実装がうまく残っているかの観点でレビューをする必要が無い。
- リリースフラグは旧実装に向いているので、いきなりマージして大丈夫かの観点でレビューする必要が無い。
- 新規追加した部分が正しい設計になっているかと、仕様を実現できているかをレビューすれば良い。

レビュー負荷が大幅に下がり、本来やりたかった設計や仕様のレビューに集中できると思います。


memo:
リリースするときのdiff
削除するときのdiff、追加行としても出てしまうが、レビューコストは低い

# 副産物

## 切り戻しが容易になる

リリースまで行った後に、バグが発覚したとします。
切り戻しの判断は、プルリクが大きくなると困難になりやすいです。
revertするとしても、その後にマージされていたマージした実装などがあると、コンフリクトを解決するのも一苦労です。

一方、本記事で解説したやり方であれば、機能追加とリリースを分けています。 
基本的には**リリースフラグを切り替えれば良いだけ**になり、切り戻しが明示的です。
もちろん、データベースのマイグレーションなどの問題は残るものの、比較的切り戻し判断・作業が簡単にできるのではないでしょうか。

## 旧実装のコードを一旦残すことができる

## リリースをデプロイ依存にさせないことができる


## 本番環境では旧仕様が動き、検証環境では新仕様をデバッグさせるという切り替えができる


[^1]: ぶっちゃけこのくらいの変更行ならレビューできる、というツッコミは無しで。あくまで例です。